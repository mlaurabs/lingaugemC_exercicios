## Tipos estruturados
- sintaxe:
```c
struct nome_do_tipo{
  // atributos
}

// declarando e inicializando uma varável de um tipo determinado
struct ponto{
  float x;
  float y;
}

struct ponto p = {10.f, 5.0f}; // essa é uma forma de incializar utlizando chaves onde cada item corresponde a um atributo do tipo estruturado
```
- utilizando ponteiros:
```c
struct ponto* pont = &p; // é atribuído ao ponteiro o endereço de uma variável do tipo sendo trabalhado

// acessando valores:
// p.x ou p.y 
// via ponteiro: (*pont).x ou pont->x

// tipos estruturados como parâmetros em função

imprime(Ponto* p){
  printf("%f - %f", p->x, p->y);
}
```
- alocação dinâmica
  - permite declarar uma variável do tipo trabalhado sem ter que declarar seu valor na incialização
  - alocando dinamicante, é possível separar o tamanho exato que o tipo estruturado ocupa em memória
```c
Ponto* p = (Ponto*) malloc(sizeof(Ponto))
p->x = 10.2;
p->y = 10.2;

// logo podemos implementar uma função que cria um objeto do tipo trabalhado --> deve retorna um ponteiro do tipo especificado
Ponto* criaObjeto(float x, floart y){
  // é preciso alocar dinamicamente e depois atribuir os valores
  Ponto* p = (Ponto*) malloc(sizeof(Ponto)) // o ponteiro p será retornado na função
  if(!p){ // caso não tenha sido possível alocar memória para o tipo
    return 0;
  }
  p->x = x;
  p->y = y;
  return p;
}
```
- uso do ***typedef***:
  - é possível definir um único termo que represente a sintaxe "struct nome_do_tipo", assim como foi feito nos exemplos anteriores
```c
typedef struct ponto Ponto;
struct ponto{
  float x, y;
}
```
- vetor de um tipo estruturado:
  - Ponto v[5] --> declarando estaticamente um vetor que guarde 5 variáveis do tipo Ponto
  - Como cada item do vetor é uma variável que representa um tipo, a partir de um item do vetor é possível acessar os atributos do objeto
```c
Ponto v[2];
v[0].x = 3;

// incializando o vetor já com os valores em a necessidade do malloc
Ponto vetor[2] = {{10.2,25.6}, {15.8, 9.3}}; // deste modo, cada sublista é um Ponto
```
## Busca Binária
- consiste em uma busca na qual o vetor é subdividido em partições
  - a comparação baseia-se com o valor no meio do vetor
    - se o elemento for menor, busca na primeira parte
    - se o elemento for maior, busca na segunda parte
    - se o elemento for igual, retorna seu índice
  - esse procedimento é continuado até que se encontre o elemento no vetor ou q chegue a uma subdivisão do vetor com zero elementos
  - A ideia de inicio, meio e fim são utilizados para controlarmos os compartimentos em q a busca irá procurar pelo elemento
```c
int buscaRec(int* vetor, int n, int elem) { // verificar se um elemento existe no vetor
	if (n <= 0) { // caso toda lista tena sido coberta 
		return 0;
	}
	else {
		int meio = n / 2; // definimos o valor do meio para a iteração
		if (elem < vetor[meio]) { // se o elemento procurado é menor que o elemento do meio
			buscaRec(vetor, n-1-meio, elem); // agora o tamanho do vetor é o último índice menor o meio
		}
		else if (elem > vetor[meio]) { // se elemento procurado for maior que o elemento do meio
			buscaRec(&vetor[meio + 1], n, elem); // agora fazmos com que o nosso ponteiro aponte para o iníce depois do meio
		}
		return 1;
	}
}

int buscaBinaria(int* vetor, int tam, int elemento) {
	int ini = 0;
	int fim = tam - 1;	
	while (ini <= fim) { // enquanto o que considerarmos de inicio for menor ou igual ao fim do vetor
		int meio = (ini + fim) / 2; // o indice do meio sempre sera a parte inteira da divisão de (ini + fim)/2
		printf("\nMeio: %d", meio);
		if (elemento < vetor[meio]) { // se o elemento vier antes do elemento do meio
			fim = meio - 1; // o fim é reduzido para o elemento anterior ao meio
		}
		else if (elemento > vetor[meio]) { // se o elemento vier depois do elemento do meio
			ini = meio + 1;  // o ini assume o inidice do elemento que vem depois do meio
		}
		else {
			return meio; // caso o elemento seja igual ao elemento do meio do vetor
		}
	}
	return -1;
}

int buscaBinRec(int ini, int fim, int* vetor, int elem){ // versão recursiva utilizando a ideia de ini e fim
    if(ini > fim){ // condição de parada: o início ser maior que o fim
        return -1;
    }else{
        int meio = (ini+fim)/2; // o meio será a base de compração
        printf("\nEsse é o valor do meio: %d", meio);
        if(elem < vetor[meio]){ // caso o elemento esteja antes do elemento do meio
            fim = meio-1; // dessa forma restringimos para até um elemento antes do meio
            buscaBinRec(ini, fim, vetor, elem);
        }else if(elem > vetor[meio]){ // caso o elemento esteja depois do elemento do meio
            ini = meio + 1; // nesse caso a busca agr é só partir do elemnto do meio
            buscaBinRec(ini, fim, vetor, elem);
        }else{
            return meio; // caso o elemento seja igual ao elemento do meio
        }
    }
}

// ainda vou comentar esse código
int buscaBinRec(int* vetor, int n, int elem){
	if(n <= 0){
           return -1;
	}else{
	    int meio = n/2;
            if(elem < vetor[meio]){
                return buscaBinRec(vetor, meio, elem);
             }else if(elem > vetor[meio]){
                 int r = buscaBinRec(&vetor[meio+1], n-1-meio, elem);
                 if(r<0) {
                    return -1;
                 }else{
                   return meio+1+r;  
                 }
             }else{
                 return meio; 
             }

}


```
## Lista Encadeada
- estrutura:
  - contém um nó ("node"), o qual é composto pelo seu conteúdo e referência para um próximo nó

![image](https://github.com/mlaurabs/lingaugemC_exercicios/assets/89169599/70bdce2c-0d5d-4fe7-9d37-3966626da29f)
- Ao contrário do vetor, a lista encadeada não exige alocação (estática ou dinâmica)
- O nó, ou seja, o último item da lista aponta para NULL. A partir disso, ***é possível identificra o último item da lista verifincando se ele aponta para NULL***
- Utlizando tipo estruturado para "criar" o nó da lista, ou seja, um molde que representa um item da lista:
```c
typedef struct node Node;
struct node{
   int info; // contém um inteiro como dado
   Node prox;	
}
```
- Como criar uma lista encadeada? Remover iten... inserir...??
```c
typedef struct node Node;
struct node{
   int info; // contém um inteiro como dado
   Node prox;	
}

Node* inserirItem(Node* lista, int item){
	Node* new = (Node*) malloc(sizeof(Node));
	if(!new){
           return NULL;
	}
	new->info = item;
	new->prox = lita;
	return new;
}


```

